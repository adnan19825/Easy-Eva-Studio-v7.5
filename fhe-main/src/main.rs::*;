
Ä·        load_keys(key_path)? // ? entpackt den ClientKey aus dem Result
    } else {
        println!("[*] Kein SchlÃ¼ssel gefunden. Generiere neues Key-Paar...");
        let (new_ck, _) = setup_fhe();
        save_keys(&new_ck, key_path)?;
        new_ck // Hier wird der nackte ClientKey zurÃ¼ckgegeben
    };

    let sk = ServerKey::new(&ck);

    // 2. Datenbank-Aktion (Persistent simuliert)
    println!("[*] VerschlÃ¼ssele Testdaten...");
    let encrypt_start = Instant::now();
    let secret_id = ck.encrypt(7);
    let secret_val = ck.encrypt(13);
    let query = ck.encrypt(5);  // Should NOT match, return 0    println!("ğŸ”’ Encryption time: {:?}", encrypt_start.elapsed());

    println!("[*] FHE-Operation lÃ¤uft auf geladenem SchlÃ¼ssel...");
    let fhe_start = Instant::now();
    let result_ct = private_retrieve_optimized(&sk, &query, &secret_id, &secret_val);
    println!("âš¡ FHE operation time: {:?}", fhe_start.elapsed());

    let dec = ck.decrypt(&result_ct);
    println!("\n=== ERGEBNIS ===");
    println!("Gefundener Wert: {} (Basis: Echte Key-Datei)", dec);

    Ok(())
}
